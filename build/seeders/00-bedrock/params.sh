#!/bin/bash
# Seeder params, used to inform the seeder orchestration about artifacts
# generated by each seeder. This file is sourced from both outside and
# inside chroot.
set -eu

source "${MATRIXOS_DEV_DIR:-/matrixos}"/headers/env.include.sh
source "${MATRIXOS_DEV_DIR}"/build/seeders/headers/seedersenv.include.sh

# SEEDER_CHROOT_NAME=abc
# Name of the chroot directory that should be created by default.
# First date of the first Monday of the current week, in the past.
SEEDER_CHROOT_NAME="bedrock-$(seeders_env.get_chroot_date)"
if [ "${SEEDER_CHROOT_NAME}" = "bedrock-" ]; then
    echo "Unable to correctly set SEEDER_CHROOT_NAME in bedrock params.sh" >&2
    exit 1
fi

# SEEDER_CHROOTS_DIR=/path/to/parent/seeder/chroots/dir
# Path to the preferred chroot directory for this seeder.
SEEDER_CHROOTS_DIR="${MATRIXOS_SEEDER_OUT_DIR}/chroots"

# PREFERRED_SEEDER_CHROOT_DIR
# Path to the currently preferred chroot directory path for this seeder.
# This way you can implement a dated seeder chroot path via SEEDER_CHROOT_NAME.
PREFERRED_SEEDER_CHROOT_DIR="${SEEDER_CHROOTS_DIR}/${SEEDER_CHROOT_NAME}"

bedrock_params._find_select_chroot_dirs_for_derived_seeder() {
    local seeder_name="${1}"
    if [ -z "${seeder_name}" ]; then
        echo "${0}: missing parameter seeder name" >&2
        return 1
    fi

    local chroot_name_prefix="${2}"
    if [ -z "${chroot_name_prefix}" ]; then
        echo "${0}: missing parameter chroot name prefix" >&2
        return 1
    fi
    local want_all_chroots="${3}"  # can be empty

    (
        shopt -s nullglob
        local regex="^${chroot_name_prefix}-[0-9]{8}$"
        local d=
        local valid_dirs=()
        for d in "${SEEDER_CHROOTS_DIR}/${chroot_name_prefix}"-*; do
            if [[ ! -d "${d}" ]]; then
                continue
            fi
            local name=
            name=$(basename "${d}")

            if ! [[ "${name}" =~ ${regex} ]]; then
                echo "${name} in ${d} does not match regex: ${regex} ..." >&2
                # not matching the expected name.
                continue
            fi

            # check for "done" seeder flag.
            local seeder_done_flag=
            seeder_done_flag="$(seeders_env.get_chroot_seeder_done_flag_file "${seeder_name}" "${d}")"
            if [ ! -f "${seeder_done_flag}" ]; then
                echo "${seeder_done_flag} does not exist. Skipping ${d} as valid ${chroot_name_prefix} rootfs." >&2
                continue
            fi
            valid_dirs+=( "${d}" )
        done
        if [[ ${#valid_dirs[@]} -eq 0 ]]; then
            echo "No ${chroot_name_prefix} dirs found in ${SEEDER_CHROOTS_DIR}" >&2
            return 1
        fi

        if [ -n "${want_all_chroots}" ]; then
            echo "${valid_dirs[@]}"  # does not handle spaces. but come on!
        else
            local latest_dir="${valid_dirs[-1]}"
            echo "${latest_dir}"
        fi
    )
}

# This function can be used by other seeders to build their own finder function.
# It takes the prefix of the seeder directory name "e.g. bedrock or gnome" to
# execute the search.
bedrock_params.find_latest_chroot_dir_for_derived_seeder() {
    local seeder_name="${1}"
    local chroot_name_prefix="${2}"
    bedrock_params._find_select_chroot_dirs_for_derived_seeder "${seeder_name}" "${chroot_name_prefix}" ""
}

# This function can be used by other seeders to get the chroot path of the latest
# Bedrock build.
bedrock_params.find_latest_chroot_dir() {
    local seeder_name="${1}"
    bedrock_params.find_latest_chroot_dir_for_derived_seeder "${seeder_name}" "bedrock"
}

# This function can be used by other seeders to get the chroot path of ALL the
# Bedrock builds.
bedrock_params.find_all_chroot_dirs() {
    local seeder_name="${1}"
    bedrock_params._find_select_chroot_dirs_for_derived_seeder "${seeder_name}" "bedrock" "1"
}
